# 2.1 变量绑定与解构

## 为何要手动设定变量的可变性
在其他大多数语言中，要么只支持声明可变的变量，要么只支持声明不可变的变量(函数式语言)，前者为编程提供了灵活性，后者为编程提供了安全性。
运行性能上的提升，将本身无需修改的变量声明为不可变在运行期会避免一些多余的 runtime 检查。

## 变量绑定

在其它语言中，我们用 var a = "hello world" 的方式给 a 赋值，也就是把等式右边的 "hello world" 字符串赋值给变量 a,
而在 Rust 中，我们这样写 let a = "hello world", 同时给这个过程起了一个另一个名字: 变量绑定。

不用赋值而用绑定?
涉及到 Rust 最核心的原则—— 所有权，
简单来讲，任何内存对象都是有主人的，而且一般情况下完全属于它的主人，绑定就是把这个对象绑定给一个变量，让这个变量成为它的主人
(在这种情况下，该对象之前的主人就会丧失对该对象的所有权)。

## 变量的可变性
Rust 的变量在默认情况下是不可变的。可以通过 mut 关键字让变量变为可变的，让设计更灵活。
如果变量 a 不可变，那么一旦为它绑定值，就不能再修改 a。

无法对不可变的变量进行重复赋值。

> 这种错误是为了避免无法预期的错误发生在我们的变量上: 一个变量往往被多处代码所使用，其中一部分代码假定该变量的值永远不会改变，
> 而另一部分代码却改变了这个值。实际开发中，这个错误是很难发现的，特别是在多线程编程中。

Rust 中，可变性非常简单，只要在变量名前加一个 mut 即可，这种显式的声明方式还会给后来人传达这样的信息: 这个变量在后面代码部分会发生改变。

使用场景: 不可变带来安全性，丧失了灵活性和性能（如果你要改变，就要重新创建一个新的变量，这里涉及到内存对象的再分配）。
可变变量的最大好处就是使用上的灵活性和性能上的提升。

> 在使用大型数据结构或者热点代码路径(被大量频繁调用)的情形下，在同一内存位置更新实例可能比复制并返回新分配的实例要更快。
> 使用较小的数据结构时，通常创建新的实例并以更具函数式的风格来编写程序，可能更容易理解，所以值得以较低的性能开销来确保代码清晰。

## 使用下划线开头忽略未使用的变量

## 变量解构
let 表达式不仅仅用于变量的绑定，还能进行复杂变量的解构: 从一个相对复杂的变量中，匹配出该变量的一部分内容。

## 解构式赋值
可以在赋值语句的左式中使用元组，切片和结构体模式了。
```rust
struct Struct {
    e: i32
}

fn main(){
    let (a,b,c,d,e);

    (a,b) = (1,2);
    [c, .., d, _] = [1,2,3,4,5];
    Struct {e ,..} = Struct {e : 5};

    assert_eq!([1,2,1,4,5],[a,b,c,d,e]);
}
```
这种使用方式跟之前的 let 保持了一致性，但是 let 会重新绑定，而这里仅仅是对之前绑定的变量进行再赋值。
使用 += 的赋值语句还不支持解构式赋值。

## 变量和常量
与不可变变量一样，常量也是绑定到一个常量名且不允许更改的值，但是常量和变量之间存在一些差异:
- 常量不允许使用 mut。常量不仅仅默认不可变，而且自始至终不可变。
- 常量使用 const 关键字而不是 let 关键字来声明，并且值的类型必须标注。

## 变量遮蔽(shadowing)
Rust 允许声明相同的变量名，在后面声明的变量会遮蔽掉前面声明的，

## 课后练习
https://practice-zh.course.rs/variables.html