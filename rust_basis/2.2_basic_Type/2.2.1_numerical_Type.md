# 数值类型

## 整数类型
每个有符号类型规定的数字范围是 -(2^(n - 1)) ~  2 ^(n -1) - 1
其中 n 是该定义形式的位长度。因此 i8 可存储数字范围是 -(2^7) ~ 2^7 - 1, 即 -128 ~ 127。
无符号类型可以存储的数字范围是 0 ~ 2 ^n - 1, 所以 u8 能够存储的数字为 0 ~ 2^8 - 1, 即 0 ~ 255。

isize 和 usize 的主要应用场景是用作集合的索引。

要显式处理可能的溢出，可以使用标准库针对原始数字类型提供的这些方法。
- 使用 wrapping_ * 方法在所有模式下都按照补码循环溢出规则处理，例如 wrapping_add
- 如果使用 checked_ * 方法时发生溢出，则返回 None 值
- 使用 overflowing_* 方法返回该值和一个指示是否存在溢出的布尔值
- 使用 saturating_* 方法，可以限定计算后的结果不超过目标类型的最大值或低于最小值，例如

```rust
assert_eq!(100u8.saturating_add(1),101);
assert_eq!(u8::MAX.saturating_add(127), u8::MAX);
```
## 浮点类型
1. 浮点数往往是你想要数字的近似表达
浮点数类型是基于二进制实现的，但是我们想要计算的数字往往是基于十进制，例如 0.1 在二进制上并不存在精确的表达形式，但是在十进制上就存在。
这种不匹配性导致一定的歧义性

2. 浮点数在某些特征上是反直觉的
f32,f64 上的比较运算实现的是
```rust
std::cmp::PartialEq
```
std::cmp::PartialEq 特征（类似其他语言的接口），但是并没有实现 std::cmp::Eq 特征，但是后者在其它数值类型上都有定义。

Rust 的 HashMap 数据结构，是一个 KV 类型的 Hash Map 实现，它对于 k 没有特定类型的限制，但是要求能用作 K 的类型必须实现了 std::cmp::Eq 特征，
因此这意味着你无法使用浮点数作为 HashMap 的 Key, 来存储键值对，但是作为对比，Rust 的整数类型，字符串类型，布尔类型都实现了该特征，因此可以作为 HashMap 的 Key。

- 避免在浮点数上测试相等性
- 当结果在数学上可能存在未定义时，需要格外的小心。

## NaN
对于数学上未定义的结果，例如对负数取平方根 -42.1.sqrt(), 会产生一个特殊的结果: Rust 的浮点数类型使用 NaN(not a number) 来处理这些情况。
所有跟 NaN 交互的操作，都会返回一个 NaN, NaN 不能用来比较

## 序列
Rust 提供了一个非常简洁的方式，用来生成连续的数值，例如 1..5, 生成从 1 到 4 的连续数字，不包含 5;
1..=5 生成从 1 到 5 的连续数字，包含 5, 它的用途很简单，常常用于循环中:
```rust
for i in 1..=5 {
    println!("{}",i);
}
```
序列只允许用于数字或字符类型，原因是: 它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以判断是否为空的类型。
```rust
for i in 'a'..='z' {
    println!("{}",i);
}
```

## 使用 As 完成类型转换
Rust 中可以使用 As 来完成一个类型到另一个类型的转换，其最常用于将原始类型转换为其他原始类型，
但是它也可以完成诸如将指针转换为地址，地址转换为指针以及将指针转换为其他指针等功能。

## 有理数和复数

1. rust 拥有相当多的数值类型
2. 类型转换必须是显式的
3. Rust 的数值上可以使用方法，例如你可以用以下方法来将 13.14 取整: 13.14_f32.round(), 这里使用了类型后缀，编译器需要知道 13.14 的具体类型。