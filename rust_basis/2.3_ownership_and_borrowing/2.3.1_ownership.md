# 所有权
所有的程序都必须和计算机内存打交道，如何从内存中申请空间来存放程序的运行内容，如何在不需要的时候释放这些空间，成了重中之重，也是所有编程语言设计的难点之一。在计算机语言不断演变过程中，出现了三种流派:
- 垃圾回收机制(GC), 在程序运行时不断寻找不再使用的内存，典型代表:Java, Go
- 手动管理内存的分配和释放: 在程序中，通过函数调用的方式来申请和释放内存，典型代表: C++
- 通过所有权来管理内存: 编译器在编译时会根据一系列规则进行检查。

Rust 选择了第三种，这种检查只发生在编译期，因此对于程序运行期，不会有任何性能上的损失。

所有权是一个新的概念，通过字符串来理解所有权的相关知识。

## 一段不安全的代码
一段 C 的代码:
```c
int * foo(){
    int a;             //变量 a 的作用域开始
    a = 100;
    char *c = "xyz";   // 变量 c 的作用域开始
    return &a;         // 变量 a 和 c 的作用域结束
}
```
这段代码虽然可以编译通过，但实际非常糟糕。变量 a 和 c 都是局部变量，函数结束后将局部变量 a 的地址返回，但局部变量 a 存在栈中，在离开作用域后， a 所申请的栈上内存都会被系统回收，从而造成了悬空指针(Dangling Pointer)的问题。这是一个非常典型的内存安全问题，虽然编译可以通过，但是运行的时候会出现错误，很多编程语言都存在。

再来看变量 c, c 的值是常值字符串，存储于常量区，可能这个函数我们只调用了一次，也可能我们不会再使用这个字符串，但 "xyz" 只有当整个程序结束后系统才能回收这片内存。

Rust 在编译的时候就可以发现内存不安全的问题，Rust 如何做到这一点呢?

## 栈(Stack) 和堆(Heap)
栈和堆是编程语言最核心的数据结构，但是在很多语言中，并不需要深入了解栈与堆。对于 Rust 这样的系统编程语言，值是位于栈上还是堆上非常重要，因为这会影响程序的行为和性能。

栈和堆的核心目标就是为了程序在运行时提供可使用的内存空间。

#### 栈

栈按照顺序存储值并以相反顺序取出值，后进先出。
增加数据叫做进栈，移出数据叫做出栈。
栈中的所有数据都必须占用已知且固定大小的内存空间，假设数据大小是未知的，在取出数据时，将无法取到想要的数据。

#### 堆

与栈不同，对于大小未知或者可能变化的数据，我们需要将它存储在堆上。

当向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的指针，该过程被称为在堆上分配内存，有时简称为“分配"(allocating)。

接着，该指针会被推入栈中，因为指针的大小是已知且固定的，在后续使用过程中，将通过栈中的指针，来获取数据在堆上的实际内存位置，进而访问该数据。

堆是一种缺乏组织的数据结构。

#### 性能区别
在栈上分配内存比在堆上分配内存要快，因为入栈时操作系统无需进行函数调用（或更慢的系统调用）来分配新的空间，只需要将新数据放入栈顶即可。相比之下，在堆上分配内存则需要更多的工作，
因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备，如果当前进程分配的内存页不足时，还需要进行系统调用来申请更多内存。因此，处理器在栈上分配数据会比在堆上分配数据更高效。

### 所有权与堆栈
当你的代码调用一个函数时，传递给函数的参数（包括可能指向堆上数据的指针和函数的局部变量）依次被压入栈中，当函数调用结束时，这些值将被从栈中按照相反的顺序依次移除。

因为堆上的数据缺乏组织，因此跟踪这些数据何时分配和释放是非常重要的，否则堆上的数据将产生内存泄漏 —— 这些数据将永远无法被回收。这就是 Rust 所有权系统为我们提供的强大保障。

在 Rust 中，明白堆栈的原理，对于理解所有权的工作原理会有很大的帮助。

## 所有权原则
> 1. Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
> 2. 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
> 3. 当所有者（变量）离开作用域范围时，这个值将被丢弃(drop)

#### 变量作用域

作用域是一个变量在程序中有效的范围，假如有这样一个变量:
```rust
let s = "hello";
```
变量 s 绑定到一个字符串字面值，该字符串字面值是硬编码到程序代码中的。s 变量从声明的点开始直到当前作用域的结束都是有效的:
```rust
{   // s 在这里无效，它尚未声明
    let s = "hello";    // 从此处起，s 是有效的
    // 使用 s
}   // 此作用域已结束，s 不再有效
```
简而言之，s从创建开始就有效，然后有效期持续到它离开作用域为止，可以看出，就作用域来说，Rust 语言跟其他编程语言没有区别。

#### 简单介绍 String 类型
已经见过字符串字面值 let s = "hello", s 是被硬编码进程序里的字符串值(类型为 &str)。
字符串字面值是很方便的，但是它并不适用于所有场景。

- 字符串字面值是不可变的，因为被硬编码到程序代码中
- 并非所有字符串的值都能在编写代码时得知

例如，字符串是需要程序运行时，通过用户动态输入然后存储在内存中的，这种情况，字符串字面值就完全无用武之地。
Rust 提供动态字符串类型: String, 该类型被分配到堆上，因此可以动态伸缩，也就能存储在编译时大小未知的文本。

```rust
let s = String::from("hello");
```
:: 是一种调用操作符，这里表示调用 String 模块中的 from 方法，由于 String 类型存储在堆上，因此它是动态的，可以修改:
```rust
let mut s = String::from("hello");
s.push_str(", world!"); // push_str() 在字符串后追加字面值
println!("{}", s); // 打印 `hello, world!'
```

关于所有权的交互。

## 变量绑定背后的数据交互

#### 转移所有权
```rust
let x = 5;
let y = x;
```
这段代码并没有发生所有权的转移: 代码首先将 5 绑定到变量 x, 接着拷贝 x 的值赋给 y, 最终 x 和 y 都等于 5,
因为整数是 Rust 基本数据类型，是固定大小的简单值，因此这两个值都是通过自动拷贝的方式来赋值的，都被存在栈中，完全无需在堆上分配内存。

整个过程中的赋值都是通过值拷贝的方式完成（发生在栈中），因此并不需要所有权转移。
这种拷贝不消耗性能吗? 实际上，这种栈上的数据足够简单，而且拷贝非常快，只需要复制一个整数大小(i32, 4 个字节)的内存即可，因此在这种情况下，拷贝的速度远比在堆上创建内存来得快的多。
实际上，Rust 基本类型都是通过自动拷贝的方式来赋值的。

```rust
let s1 = String::from("hello");
let s2 = s1;
```
对于基本类型(存储在栈上)，Rust会自动拷贝，但是 String 不是基本类型，而且是存储在堆上的，因此不能自动拷贝。

String 类型是一个复杂类型，由存储在栈中的堆指针、字符串长度、字符串容量共同组成，其中堆指针是最重要的，它指向了真实存储字符串内容的堆内存，至于长度和容量，容量是堆内存分配空间的大小，长度是目前已经使用的大小。

String 类型指向了一个堆上的空间，这里存储着它的真实数据，下面对上面代码中的
```rust
let s2 = s1;
```
分成两种情况讨论:
1. 拷贝 String 和存储在堆上的字节数组，如果该语句是拷贝所有数据(深拷贝)，那么无论是 string 本身还是底层的堆上数据，都会被全部拷贝，对性能造成很大影响。

2. 只拷贝 String 本身，这样的拷贝非常快，
在 64位机器上就拷贝了 8 字节的指针，8 字节的长度， 8 字节的容量，总共 24 字节。
带来了新的问题: 一个值只允许有一个所有者，而现在这个值(堆上的真实字符串数据)有了两个所有者: s1 和 s2。

假定一个值可以拥有两个所有者:

当变量离开作用域后，Rust 会调用 drop 函数并清理变量的堆内存。不过由于两个 String 变量指向了同一位置，产生一个问题: 当 s1 和 s2 离开作用域，它们都会尝试释放相同的内存。这是一个叫做 二次释放(double free) 的错误，也是之前提到的内存安全性 BUG 之一。两次释放(相同)内存会导致内存污染，它可能会导致潜在的安全漏洞。

Rust 这样解决问题:
**当 s1 被赋予 s2 后，Rust 认为 s1 不再有效，因此也无需在 s1 离开作用域后 drop 任何东西，这就是把所有权从 s1 转移给了 s2, s1 在被赋予 s2 后就马上失效了。**

在所有权转移后再来使用旧的所有者，会发生什么:
```rust
let s1 = String::from("hello");
let s2 = s1;

println!("{}, world", s1);
```

浅拷贝(shallow copy) 和深拷贝(deep copy), 拷贝指针、长度和容量而不拷贝数据听起来就像浅拷贝，但是又因为 Rust 同时使第一个变量 s1 无效了，因此这个操作被称为移动(move), 而不是浅拷贝。

解读为 s1 被移动到了 s2 中。

```rust
fn main(){
    let x: &str = "hello, world!"
    let y  = x;
    println!("{},{}",x, y);
}
```
这段代码和之前的 String 有一个本质上的区别: 在 String 的例子中 s1 持有了通过 String::from("hello") 创建的值的所有权，
而在这个例子中，x 只是引用了存储在二进制中的字符串 "hello, world", 并没有持有所有权。

let y = x 中，仅仅是对引用进行了拷贝，此时 y 和 x 都引用了同一个字符串。

#### 克隆(深拷贝)
首先，**Rust 永远也不会自动创建数据的“深拷贝”**。因此，任何自动的复制都不是深拷贝，可以被认为对运行时性能影响较小。
如果我们确实需要深度复制 String 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 clone 的方法。

```rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
```
这段代码能够正常运行，说明 s2 确实完整的复制了 s1 的数据。

如果代码性能无关紧要，例如初始化程序或者在某段时间只会执行寥寥数次时，你可以使用 clone 来简化编程。
但是对于执行较为频繁的代码(热点路径)，使用 clone 会极大的降低程序性能，需要小心使用。

#### 拷贝(浅拷贝)
浅拷贝只发生在栈上，因此性能很高，在日常编程中，浅拷贝无处不在。
回到之前看过的例子:
```rust
let x = 5;
let y = x;

println!("x = {}, y = {}," x, y);
```
这段代码没有调用 clone, 不过依然实现了类似深拷贝的效果 —— 没有报所有权的错误。

> 原因: 像整型这样的基本类型在编译时是已知大小的，会被存储在栈上，所以拷贝其实际的值是快速的。
> 这意味着没有理由在创建变量 y 后使 x 无效(x,y 都仍然有效)。
> 这里没有深浅拷贝的区别，因此这里调用clone 并不会与通常的浅拷贝有什么不同，我们可以不用管它（理解成在栈上做了深拷贝 ）。


Rust 由一个叫做 Copy 的特征，可以用在类似整型这样在栈中存储的类型。如果一个类型拥有 Copy 特征，一个旧的变量在被赋值给其他变量后仍然可用，也就是赋值的过程即是拷贝的过程。

那么什么类型是可 Copy 的呢？可以查看给定类型的文档来确认，这里可以给出一个通用的规则：
**任何基本类型的组合可以 Copy, 不需要分配内存或某种形式资源的类型是可以 Copy 的。**

- 所有整数类型，比如 u32
- 布尔类型, bool , 它的值是 true 和 false
- 所有浮点数类型，比如 f64
- 字符类型, char
- 元组，当且仅当其包含的类型也都是 Copy 的时候。比如 (i32,i32) 是 Copy 的，但 (i32, String) 就不是
- 不可变引用 &T, 例如转移所有权中的最后一个例子，但是可变引用 &mut T 是不可以 Copy 的
  
## 函数传值与返回

将值传递给函数，一样会发生移动 或者 复制，就跟 let 语句一样，下面的代码展示了所有权，作用域的规则:
```rust
fn main(){
    let s = String::from("hello"); // s 进入作用域
    takes_ownership(s);             // s 的值进入到函数里 ...
                                    // ... 所以到这里不再有效
    let x = 5;                      // x 进入作用域

    makes_copy(x);                  // x 应该移动函数里
                                    // 但 i32 是 Copy 的，所以在后面可继续使用 x 
    
} // 这里 x 先移出了作用域，然后是 s。 但因为 s 的值已被移走,
// 所以不会有特殊操作

fn takes_ownership(some_string: String){    // some_string 进入作用域
    println!("{}", some_string);
}  // 这里, some_string 移出作用域并调用 `drop` 方法。占用的内存被释放

fn makes_copy(some_integer: i32){ // some_integer 进入作用域
    println!("{}", some_integer);
} // 这里， some_integer 移出作用域。不会有特殊操作
```
在 takes_ownership 之后，再使用 s, 产生报错。
例如添加一行 println!("在 move 进函数后继续使用 s: {}", s);

同样的，函数返回值也有所有权，例如:
```rust
fn main(){
    let s1 = gives_ownership();     // gives_ownership 将返回值
                                    // 移给 s1 
    let s2 = String::from("hello"); // s2 进入作用域
    let s3 = takes_and_gives_back(s2);      // s2 被移动到 takes_and_gives_back 中，
                                            // 它也将返回值移给 s3
} // 这里 s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走
// 所以什么也不会发生。 s1 移出作用域并被丢弃 

fn gives_ownership() -> String {    // gives_ownership 将返回值移动给
                                    // 调用它的函数
    let some_string = String::from("hello"); // some_string 进入作用域 
    some_string                              // 返回 some_string 并移出给调用的函数
}

// takes_and_gives_back 将传入字符串并返回该值
fn takes_and_gives_back(a_string: String) -> String {  // a_string 进入作用域 
    a_string // 返回 a_string 并移出给调用的函数
}
```

所有权很强大，避免了内存的不安全性，但是也带来了一个新麻烦： 总是把一个值传来传去使用它。
传入一个函数，很可能还要从该函数传出去，结果就是语言表达变得非常啰嗦， Rust 提供了新功能解决这个问题。

## 部分 move
当解构一个变量时，可以同时使用 move 和引用模式绑定的方式。当这么做时，部分 move 就会发生: 变量中一部分的所有权被转移给其他变量，而另一部分我们获取了它的引用。

在这种情况下，原变量将无法再被使用，但是它没有转移所有权的那一部分依然可以使用，也就是之前被引用的那部分。

```rust
fn main(){
    #[derive(Debug)]
    struct Person {
        name: String,
        age: Box<u8>,
    }

    let person = Person {
        name: String::from("Alice"),
        age: Box::new(20),
    };

    // 通过这种解构式模式匹配， person.name 的所有权被转移给新的变量 `name`
    // 但是，这里 `age` 变量却是对 person.age 的引用，这里 ref 的使用相当于: let age = &person.age 
    let person {name , ref age} = person;

    println!("The person's age is {}", age);
    
    println!("The person's name is {}", name);

    // Error! 原因是 person 的一部分已经被转移了所有权，因此我们无法再使用它
    println!("The person struct is {:?}", person);

    // 虽然 `person` 作为一个整体无法再被使用，但是 `person.age` 依然可以使用
    println!("The person's age from person struct is {}", person.age);
}
```