# 动态数组 Vector
动态数组类型用 Vec<T> 表示，事实上，在之前的章节，它多次出现。
动态数组允许你存储多个值，这些值在内存中一个紧挨着另一个排列，因此访问其中某个元素的成本非常低。
动态数组只能存储相同类型的元素，如果你想存储不同类型的元素，可以使用之前的枚举类型或者特征对象。

当我们想拥有一个列表，里面都是相同类型的数据时，动态数组非常有用。

## 创建动态数组
在 Rust 中，有多种方式可以创建动态数组。

### Vec::new
调用了 Vec 中的 new 关联函数:
```rust
let v: Vec<i32> = Vec::new();
```
v 被显式地声明了类型 Vec<i32>, 这是因为 Rust 编译器无法从 Vec::new() 中得到任何关于类型的暗示信息，无法推导出 v 的具体类型，
但是如果向里面添加一个元素后，一切又不同了:
```rust
let mut v = Vec::new();
v.push(1);
```
v 无需手动声明类型，因为编译器通过 v.push(1), 推测出 v 中的元素类型是 i32, 因此推导出 v 的类型就是 Vec<i32>。

> 如果预先知道要存储的元素个数，可以使用 Vec::with_capacity(capacity) 创建动态数组，这样可以因为避免插入大量新数据导致频繁的内存分配和拷贝，
> 提升性能。

### vec![]
还可以使用宏 vec! 来创建数组，与 Vec::new 有所不同，前者能在创建同时给予初始化值:
```rust
let v = vec![1, 2, 3];
```
同样，此处的 v 也无需标注类型，编译器只检查它内部的元素即可自动推导出 v 的类型是 Vec<i32>（Rust 中，整数默认类型是 i32, 在数值类型中有详细介绍）。

## 更新 Vector
向数组尾部添加元素，可以使用 push 方法:
```rust
let mut v = Vec::new();
v.push(1);
```

## Vector 与其元素共存亡
与结构体一样，Vector 类型在超出作用域范围后，会被自动删除:
```rust
{
    let v = vec![1, 2, 3];
} // <- v 超出作用域并在此处被删除
```
当 Vector 被删除后，它内部存储的所有内容也会随之被删除。目前来看，这种解决方案简单直白，但是当 Vector 中的元素被引用后，事情可能没那么简单。

## 从 Vector 中读取元素
读取指定位置的元素有两种方式可选:
- 通过下标索引访问
- 使用 get 方法
```rust
let v = vec![1, 2, 3, 4, 5];

let third: &i32 = &v[2];
println!("第三个元素是 {}", third);

match v.get(2) {
    Some(third) => println!("第三个元素是 {third}"),
    None => println!("没有第三个元素"),
}
```
&v[2] 表示借用 v 中的第三个元素，最终会获得该元素的引用。
而 v.get(2) 也是访问第三个元素，不同的是返回了 Option<&T>, 需要额外的 match 来匹配解构出具体的值。

### 下标索引与 .get 的区别
两种方法都能成功地读取到指定的数组元素，为什么会存在两种方法? .get 会增加使用复杂度，涉及到数组越界的问题:
```rust
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &v[100];
let does_not_exist = v.get(100);
```
&v[100] 的方式会导致程序报错退出，因为发生了数组越界访问，但是 v.get 就不会，它在内部做了处理，有值的时候就返回 Some(T), 无值的时候返回 None，
因此 v.get 的使用方式非常安全。

选择的问题: 确保索引不会越界时，就用索引访问，否则用 .get。
如果访问第几个数组元素并不取决于我们，而是取决于用户的输入时，用 .get 会非常合适。

### 同时借用多个数组元素
涉及到借用数组元素，可能遇到同时借用多个数组元素的情况，在所有权和借用章节中讲过借用规则
```rust
let mut v = vec![1, 2, 3, 4, 5];
let first = &v[0];
v.push(6);
println!("The first element is: {}", first);
```
> ps: 作者给了一个非常好的从头造轮子的连接，自己实现标准库中的 std::Vec, 
> 链接是 Rust 秘典(死灵书)
> https://nomicon.purewhite.io/vec/vec.html
> 具体的实现放在当前目录下的新文件夹 rust_pure_white
